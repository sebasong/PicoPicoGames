/*
  PicoPicoGames

  Copyright (c) 2009, Hiromitsu Yamaguchi, All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer. 

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution. 

  3. Neither the name of the Yamagame nor the names of its contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission. 

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "QBGame.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
//#include "PPGameText.h"
#include "PPGameSound.h"
#include "PPGameMap.h"
#include "PPGameUtil.h"

//static PPGameText* text;
static PPGameMap* gameMap=NULL;

static int font_maruindex=-1;
static int font_tenindex=-1;

static const unsigned char dakutable1[]={
0xE3,0x81,0x8C,0xE3,0x81,0x8E,0xE3,0x81,0x90,0xE3,0x81,0x92,0xE3,0x81,0x94,
0xE3,0x81,0x96,0xE3,0x81,0x98,0xE3,0x81,0x9A,0xE3,0x81,0x9C,0xE3,0x81,0x9E,0xE3,
0x81,0xA0,0xE3,0x81,0xA2,0xE3,0x81,0xA5,0xE3,0x81,0xA7,0xE3,0x81,0xA9,0xE3,0x81,
0xB0,0xE3,0x81,0xB3,0xE3,0x81,0xB6,0xE3,0x81,0xB9,0xE3,0x81,0xBC,0xE3,0x82,0xAC,
0xE3,0x82,0xAE,0xE3,0x82,0xB0,0xE3,0x82,0xB2,0xE3,0x82,0xB4,0xE3,0x82,0xB6,0xE3,
0x82,0xB8,0xE3,0x82,0xBA,0xE3,0x82,0xBC,0xE3,0x82,0xBE,0xE3,0x83,0x80,0xE3,0x83,
0x82,0xE3,0x83,0x85,0xE3,0x83,0x87,0xE3,0x83,0x89,0xE3,0x83,0x90,0xE3,0x83,0x93,
0xE3,0x83,0x96,0xE3,0x83,0x99,0xE3,0x83,0x9C,0x00};

static const unsigned char dakutable1_1[]={
0xE3,0x81,0x8B,0xE3,0x81,0x8D,0xE3,0x81,0x8F,0xE3,0x81,0x91,0xE3,0x81,0x93,
0xE3,0x81,0x95,0xE3,0x81,0x97,0xE3,0x81,0x99,0xE3,0x81,0x9B,0xE3,0x81,0x9D,0xE3,
0x81,0x9F,0xE3,0x81,0xA1,0xE3,0x81,0xA4,0xE3,0x81,0xA6,0xE3,0x81,0xA8,0xE3,0x81,
0xAF,0xE3,0x81,0xB2,0xE3,0x81,0xB5,0xE3,0x81,0xB8,0xE3,0x81,0xBB,0xE3,0x82,0xAB,
0xE3,0x82,0xAD,0xE3,0x82,0xAF,0xE3,0x82,0xB1,0xE3,0x82,0xB3,0xE3,0x82,0xB5,0xE3,
0x82,0xB7,0xE3,0x82,0xB9,0xE3,0x82,0xBB,0xE3,0x82,0xBD,0xE3,0x82,0xBF,0xE3,0x83,
0x81,0xE3,0x83,0x84,0xE3,0x83,0x86,0xE3,0x83,0x88,0xE3,0x83,0x8F,0xE3,0x83,0x92,
0xE3,0x83,0x95,0xE3,0x83,0x98,0xE3,0x83,0x9B,0x00};

static const unsigned char dakutable2[]={
0xE3,0x81,0xB1,0xE3,0x81,0xB4,0xE3,0x81,0xB7,0xE3,0x81,0xBA,0xE3,0x81,0xBD,
0xE3,0x83,0x91,0xE3,0x83,0x94,0xE3,0x83,0x97,0xE3,0x83,0x9A,0xE3,0x83,0x9D,0x00};

static const unsigned char dakutable2_1[]={
0xE3,0x81,0xAF,0xE3,0x81,0xB2,0xE3,0x81,0xB5,0xE3,0x81,0xB8,0xE3,0x81,0xBB,
0xE3,0x83,0x8F,0xE3,0x83,0x92,0xE3,0x83,0x95,0xE3,0x83,0x98,0xE3,0x83,0x9B,0x00};

static const unsigned char fontTable[]={
0xE3,0x80,0x80,0xEF,0xBC,0x81,0xE2,0x80,0x9D,0xEF,0xBC,0x83,0xEF,0xBC,0x84,
0xEF,0xBC,0x85,0xEF,0xBC,0x86,0xE2,0x80,0x99,0xEF,0xBC,0x88,0xEF,0xBC,0x89,0xEF,
0xBC,0x8A,0xEF,0xBC,0x8B,0xEF,0xBC,0x8C,0xE3,0x83,0xBC,0xEF,0xBC,0x8E,0xEF,0xBC,
0x8F,0xEF,0xBC,0x90,0xEF,0xBC,0x91,0xEF,0xBC,0x92,0xEF,0xBC,0x93,0xEF,0xBC,0x94,
0xEF,0xBC,0x95,0xEF,0xBC,0x96,0xEF,0xBC,0x97,0xEF,0xBC,0x98,0xEF,0xBC,0x99,0xEF,
0xBC,0x9A,0xE5,0x91,0xAA,0xEF,0xBC,0x9C,0xEF,0xBC,0x9D,0xEF,0xBC,0x9E,0xEF,0xBC,
0x9F,0xEF,0xBC,0xA0,0xEF,0xBC,0xA1,0xEF,0xBC,0xA2,0xEF,0xBC,0xA3,0xEF,0xBC,0xA4,
0xEF,0xBC,0xA5,0xEF,0xBC,0xA6,0xEF,0xBC,0xA7,0xEF,0xBC,0xA8,0xEF,0xBC,0xA9,0xEF,
0xBC,0xAA,0xEF,0xBC,0xAB,0xEF,0xBC,0xAC,0xEF,0xBC,0xAD,0xEF,0xBC,0xAE,0xEF,0xBC,
0xAF,0xEF,0xBC,0xB0,0xEF,0xBC,0xB1,0xEF,0xBC,0xB2,0xEF,0xBC,0xB3,0xEF,0xBC,0xB4,
0xEF,0xBC,0xB5,0xEF,0xBC,0xB6,0xEF,0xBC,0xB7,0xEF,0xBC,0xB8,0xEF,0xBC,0xB9,0xEF,
0xBC,0xBA,0xEF,0xBC,0xBB,0xEF,0xBF,0xA5,0xEF,0xBC,0xBD,0xEF,0xBC,0xBE,0xEF,0xBC,
0xBF,0xEF,0xBD,0x80,0xEF,0xBD,0x81,0xEF,0xBD,0x82,0xEF,0xBD,0x83,0xEF,0xBD,0x84,
0xEF,0xBD,0x85,0xEF,0xBD,0x86,0xEF,0xBD,0x87,0xEF,0xBD,0x88,0xEF,0xBD,0x89,0xEF,
0xBD,0x8A,0xEF,0xBD,0x8B,0xEF,0xBD,0x8C,0xEF,0xBD,0x8D,0xEF,0xBD,0x8E,0xEF,0xBD,
0x8F,0xEF,0xBD,0x90,0xEF,0xBD,0x91,0xEF,0xBD,0x92,0xEF,0xBD,0x93,0xEF,0xBD,0x94,
0xEF,0xBD,0x95,0xEF,0xBD,0x96,0xEF,0xBD,0x97,0xEF,0xBD,0x98,0xEF,0xBD,0x99,0xEF,
0xBD,0x9A,0xEF,0xBD,0x9B,0xEF,0xBD,0x9C,0xEF,0xBD,0x9D,0xE3,0x80,0x9C,0xE3,0x80,
0x80,0xE3,0x81,0x82,0xE3,0x81,0x84,0xE3,0x81,0x86,0xE3,0x81,0x88,0xE3,0x81,0x8A,
0xE3,0x82,0x89,0xE3,0x82,0x8A,0xE3,0x82,0x8B,0xE3,0x82,0x8C,0xE3,0x82,0x8D,0xE3,
0x83,0x8F,0xE3,0x83,0x92,0xE3,0x83,0x95,0xE3,0x83,0x98,0xE3,0x83,0x9B,0xE3,0x80,
0x80,0xE3,0x81,0x8B,0xE3,0x81,0x8D,0xE3,0x81,0x8F,0xE3,0x81,0x91,0xE3,0x81,0x93,
0xE3,0x82,0x93,0xE4,0xB8,0xB8,0xE3,0x81,0x83,0xE3,0x81,0xA3,0xE3,0x81,0x87,0xE3,
0x83,0x9E,0xE3,0x83,0x9F,0xE3,0x83,0xA0,0xE3,0x83,0xA1,0xE3,0x83,0xA2,0xE3,0x80,
0x80,0xE3,0x81,0x95,0xE3,0x81,0x97,0xE3,0x81,0x99,0xE3,0x81,0x9B,0xE3,0x81,0x9D,
0xE3,0x82,0x83,0xE3,0x82,0x85,0xE3,0x82,0x87,0xE3,0x80,0x81,0xE3,0x80,0x82,0xE3,
0x83,0xA4,0xE3,0x83,0xA6,0xE3,0x83,0xA8,0xE3,0x83,0xAF,0xE3,0x83,0xB2,0xE3,0x80,
0x80,0xE3,0x81,0x9F,0xE3,0x81,0xA1,0xE3,0x81,0xA4,0xE3,0x81,0xA6,0xE3,0x81,0xA8,
0xE3,0x82,0xA2,0xE3,0x82,0xA4,0xE3,0x82,0xA6,0xE3,0x82,0xA8,0xE3,0x82,0xAA,0xE3,
0x83,0xA9,0xE3,0x83,0xAA,0xE3,0x83,0xAB,0xE3,0x83,0xAC,0xE3,0x83,0xAD,0xE3,0x80,
0x80,0xE3,0x81,0xAA,0xE3,0x81,0xAB,0xE3,0x81,0xAC,0xE3,0x81,0xAD,0xE3,0x81,0xAE,
0xE3,0x82,0xAB,0xE3,0x82,0xAD,0xE3,0x82,0xAF,0xE3,0x82,0xB1,0xE3,0x82,0xB3,0xE3,
0x83,0xB3,0xE7,0x82,0xB9,0xE3,0x82,0xA3,0xE3,0x83,0x83,0xE3,0x82,0xA7,0xE3,0x80,
0x80,0xE3,0x81,0xAF,0xE3,0x81,0xB2,0xE3,0x81,0xB5,0xE3,0x81,0xB8,0xE3,0x81,0xBB,
0xE3,0x82,0xB5,0xE3,0x82,0xB7,0xE3,0x82,0xB9,0xE3,0x82,0xBB,0xE3,0x82,0xBD,0xE3,
0x83,0xA3,0xE3,0x83,0xA5,0xE3,0x83,0xA7,0xE3,0x80,0x8C,0xE3,0x80,0x8D,0xE3,0x80,
0x80,0xE3,0x81,0xBE,0xE3,0x81,0xBF,0xE3,0x82,0x80,0xE3,0x82,0x81,0xE3,0x82,0x82,
0xE3,0x82,0xBF,0xE3,0x83,0x81,0xE3,0x83,0x84,0xE3,0x83,0x86,0xE3,0x83,0x88,0xE3,
0x82,0xA1,0xE3,0x82,0xA9,0xE3,0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,
0x80,0xE3,0x82,0x84,0xE3,0x82,0x86,0xE3,0x82,0x88,0xE3,0x82,0x8F,0xE3,0x82,0x92,
0xE3,0x83,0x8A,0xE3,0x83,0x8B,0xE3,0x83,0x8C,0xE3,0x83,0x8D,0xE3,0x83,0x8E,0xE3,
0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,0x80,0xE3,0x80,
0x80,0x00};

static const unsigned char maruCode[]={
0xE4,0xB8,0xB8,0x00};

static const unsigned char tenCode[]={
0xE7,0x82,0xB9,0x00};

static int searchno(const unsigned char *str,const unsigned char *tbl)
{
	int i,l;
	l = strlen((char*)tbl);
	for (i=0;i<l;i+=3) {
		if (str[0] == tbl[i] && str[1] == tbl[i+1] && str[2] == tbl[i+2])
			return i/3;
	}
	return -1;
}

static unsigned char colorTable[][4] = {
	{0x00,0x00,0x00,0xff},	//0
	{0x00,0x00,0xa0,0xff},	//1
	{0x00,0xa0,0x00,0xff},	//2
	{0x00,0xa0,0xa0,0xff},	//3
	{0xa0,0x00,0x00,0xff},	//4
	{0xa0,0x00,0xa0,0xff},	//5
	{0xa0,0xa0,0x00,0xff},	//6
	{0xa0,0xa0,0xa0,0xff},	//7
	{0x40,0x40,0x40,0xff},	//8
	{0x00,0x00,0xff,0xff},	//9
	{0x00,0xff,0x00,0xff},	//10
	{0x00,0xff,0xff,0xff},	//11
	{0xff,0x00,0x00,0xff},	//12
	{0xff,0x00,0xff,0xff},	//13
	{0xff,0xff,0x00,0xff},	//14
	{0xff,0xff,0xff,0xff},	//15
	{0x00,0x00,0x00,0xff},	//16
	{0x00,0x00,0xff,0xff},	//17
	{0x00,0xff,0x00,0xff},	//18
	{0x00,0xff,0xff,0xff},	//19
	{0xff,0x00,0x00,0xff},	//20
	{0xff,0x00,0xff,0xff},	//21
	{0xff,0x80,0x00,0xff},	//22
	{0x80,0x80,0x80,0xff},	//23
	{0x40,0x40,0x40,0xff},	//24
	{0x40,0x40,0xff,0xff},	//25
	{0x40,0xff,0x40,0xff},	//26
	{0x40,0xff,0xff,0xff},	//27
	{0xff,0x40,0x40,0xff},	//28
	{0xff,0x40,0xff,0xff},	//29
	{0xff,0xff,0x40,0xff},	//30
	{0xff,0xff,0xff,0xff},	//31
	{0x00,0x20,0xff,0xff},	//32
	{0x00,0x40,0xff,0xff},	//33
	{0x00,  96,0xff,0xff},	//34
	{0x00,0x80,0xff,0xff},	//35
	{0x00, 160,0xff,0xff},	//36
	{0x00, 192,0xff,0xff},	//37
	{0x00, 224,0xff,0xff}	//38
};

//static unsigned short rand_ct = 0;

static int QBRand()
{
	return rand();
//	rand_ct += ((rand_ct>>2)+1);
//	return rand_ct;
}

QBGame::QBGame()
{
	text = NULL;
	poly = NULL;
	color = 15;
//	step = 0;
	exitGame = false;
	chooseBGM = 0;
	playBGM = 0;
	polyCount = 0;
	curMenu = 0;
	touchCount = 0;
	keyRepeatTimer = 0;
	
	for (int i=0;i<QBGAME_MAX_COLORTABLE;i++) {
		colortable[i][0] = 0;
		colortable[i][1] = 0;
		colortable[i][2] = 0;
		colortable[i][3] = 0;
	}
	for (int i=0;i<sizeof(colorTable)/(sizeof(unsigned char)*4);i++) {
		colortable[i][0] = colorTable[i][0];
		colortable[i][1] = colorTable[i][1];
		colortable[i][2] = colorTable[i][2];
		colortable[i][3] = colorTable[i][3];
	}
	
	text = new PPGameText();
	
	prekey = 0;
	key = 0;
}

QBGame::~QBGame()
{
	releaseBGM();
	delete gameMap;
	//[gameMap release];
	gameMap = NULL;
	//text = NULL;
	if (text) {
		delete text;
	}
}

/*
void QBGame::SetText(void* intext)
{
	text = (PPGameText*)intext;
}
*/

bool QBGame::KeyWait(unsigned long mask,bool t)
{
	if (t == false) {
		if ((!(prekey & mask)) && (key & mask)) {
			return true;
		}
	} else {
		if ((!(key & mask)) && (prekey & mask)) {
			return true;
		}
	}
	return false;
}

bool QBGame::Key(unsigned long mask)
{
	if ((key & mask)) {
		return true;
	}
	return false;
}

int QBGame::gameIdle(unsigned long ikey,PPGamePoly* ipoly,PPGameSplite* g,void* controller)
{
	if (StringTextureID() >= 0) {
		PPGameTextureInfo* list = TextureInfo();
		if (list) {
			list[StringTextureID()].group = text->group;
			text->idle(g,StringTextureID());
		}
	}
	poly = ipoly;
	key = ikey;
	Idle();
	idleBGM(controller);
	prekey = key;
	return polyCount;
}

int QBGame::Idle()
{
	return 0;
}

void QBGame::Clear()
{
	polyCount = 0;
}

int QBGame::GetParam(const char* key,int defaultValue)
{
	return PPGame_GetParam(key,defaultValue);
#if 0
	id v = [[NSUserDefaults standardUserDefaults] objectForKey:[NSString stringWithUTF8String:key]];
	if (v != nil) {
		return [v intValue];
	}
	return defaultValue;
#endif
}

void QBGame::SetParam(const char* key,int value)
{
	PPGame_SetParam(key,value);
//	[[NSUserDefaults standardUserDefaults] setObject:[NSNumber numberWithInt:value] forKey:[NSString stringWithUTF8String:key]];
}

unsigned char* QBGame::GetData(const char* key,int* dataSize)
{
	return PPGame_GetData(key,dataSize);
#if 0
	NSData* data = [[NSUserDefaults standardUserDefaults] objectForKey:[NSString stringWithUTF8String:key]];
	*dataSize = [data length];
	return (unsigned char*)[data bytes];
#endif
}

void QBGame::SetData(const char* key,unsigned char* data,int dataSize)
{
	PPGame_SetData(key,data,dataSize);
//	[[NSUserDefaults standardUserDefaults] setObject:[NSData dataWithBytes:data length:dataSize] forKey:[NSString stringWithUTF8String:key]];
}

unsigned char* QBGame::GetRGBColor(int color,unsigned char* r,unsigned char* g,unsigned char* b)
{
	unsigned char* c = &colortable[color][0];
	*r = c[0];
	*g = c[1];
	*b = c[2];
	return c;
}

int QBGame::SetRGBColor(int color,unsigned char r,unsigned char g,unsigned char b)
{
	if (color >= 0 && color < QBGAME_MAX_COLORTABLE) {
		unsigned char* c = &colortable[color][0];
		c[0] = r;
		c[1] = g;
		c[2] = b;
	}
	return 0;
}

void QBGame::Color(int incolor)
{
	color = incolor;
}

void QBGame::Locate(int x,int y)
{
	locatex = x*16;
	locatey = y*16;
}

void QBGame::Offset(int x,int y)
{
	locatex = x;
	locatey = y;
}

void QBGame::Print(const char* format,...)
{
	int x,y;
	x = locatex;
	y = locatey;
	if (font_maruindex < 0) {
		font_maruindex = ::searchno(maruCode,fontTable)+32;
	}
	if (font_tenindex < 0) {
		font_tenindex = ::searchno(tenCode,fontTable)+32;
	}
	{
		int len = 0;
		va_list args;
		va_start(args,format);
		{
			len = vsnprintf(NULL,0,format,args)+1;
			if (len > 0) {
				unsigned char* str = (unsigned char*)calloc(1,len);
				if (str) {
					vsnprintf((char*)str,len,format,args);
					for (int i=0;i<len-1;i++) {
						if (str[i] < 0x80) {
							//半角アルファベット//
							PutFont(x,y,str[i],colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
						} else {
							bool found=false;
							int index = -1;
							//濁音//
							if (!found) {
								index = ::searchno(&str[i],dakutable1);
								if (index >= 0) {
									index = ::searchno(&dakutable1_1[index*3],fontTable);
									if (index >= 0) {
										PutFont(x,y,index+32,colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
										PutFont(x,y-16,font_tenindex,colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
										i += 2;
									}
								}
							}
							//半濁音//
							if (!found) {
								index = ::searchno(&str[i],dakutable2);
								if (index >= 0) {
									index = ::searchno(&dakutable2_1[index*3],fontTable);
									if (index >= 0) {
										PutFont(x,y,index+32,colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
										PutFont(x,y-16,font_maruindex,colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
										i += 2;
									}
								}
							}
							//その他の五十音//
							if (!found) {
								index = ::searchno(&str[i],fontTable);
								if (index >= 0) {
									PutFont(x,y,index+32,colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
									i += 2;
								}
							}
						}
						//Put(x*16,y*16,str[i]);
						//Put((_fx-1)*16/resolutionValue()+_printOffsetX,(_fy-1)*16/resolutionValue()+_printOffsetY,str[i],fontTextureID(),1);
						//Splite((_fx-1)*16/resolutionValue()+_printOffsetX,(_fy-1)*16/resolutionValue()+_printOffsetY,0,str[i],fontTextureID(),1);
						//_fx +=_fscalex;
						x += 16;
					}
					free(str);
				}
			}
		}
	}
	locatex = x;
	locatey = y;
}

void QBGame::String(const char* format,...)
{
	int x,y;
	x = locatex;
	y = locatey;
	int i=polyCount;
	if (text) {
		int len = 0;
		va_list args;
		va_start(args,format);
		{
			len = vsnprintf(NULL,0,format,args)+1;
			if (len > 0) {
				char* str = (char*)calloc(1,len);
				if (str) {
					vsnprintf(str,len,format,args);
					//poly[i].r = colortable[color][0];
					//poly[i].g = colortable[color][1];
					//poly[i].b = colortable[color][2];
					text->setColor(colortable[color][0],colortable[color][1],colortable[color][2],colortable[color][3]);
					i += text->print(&poly[i], str, x*16, y*16);
					//for (int i=0;i<len-1;i++) {
						//Put((_fx-1)*16/resolutionValue(),(_fy-1)*16/resolutionValue(),str[i],fontTextureID());
						//Splite((_fx-1)*16/resolutionValue(),(_fy-1)*16/resolutionValue(),0,str[i],fontTextureID());
						//_fx ++;
					//}
					x += len;
					free(str);
				}
			}
		}
	}
	polyCount = i;
	Locate(x,y);
}

void QBGame::Play(const char* mml,int ch)
{
	if (PPGame_GetSoundEnable()) PPGameMML_Play(mml,ch);
}

void QBGame::Stop(int ch)
{
	if (PPGame_GetSoundEnable()) PPGameMML_Stop(ch);
}

bool QBGame::IsPlaying(int ch)
{
	if (PPGame_GetSoundEnable()) return false;
	return PPGameMML_IsPlaying(ch);
//	return false;
}

/*
void QBGame::PutFont(int x,int y,int pat,int group,int image,unsigned char r,unsigned char g,unsigned char b)
{
	int i = polyCount;

	poly[i].r = r;
	poly[i].g = g;
	poly[i].b = b;
	poly[i].alpha = 255;
//	poly[i].blend = GLGameBlend_Color;
	poly[i++].splite(x,y,pat,group,image);
	
	polyCount++;
}
*/

void QBGame::Put(int x,int y,int pat,int group,int image,unsigned char r,unsigned char g,unsigned char b,unsigned char a)
{

	int i = polyCount;
	poly[i].r = r;
	poly[i].g = g;
	poly[i].b = b;
	poly[i].alpha = a;
	poly[i++].splite(x,y,pat,group,image);
	polyCount = i;
/*
	int i = polyCount;
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x,y,x+16,y+16);
	polyCount = i;
*/
}

/*
void QBGame::Put(int x,int y,int pat)
{
}
*/

void QBGame::PutFont(int x,int y,int pat,unsigned char r,unsigned char g,unsigned char b,unsigned char a)
{
	int i = polyCount;

	poly[i].r = r;
	poly[i].g = g;
	poly[i].b = b;
	poly[i].alpha = a;
//	poly[i].blend = GLGameBlend_Color;
	poly[i++].splite(x,y,pat,0,0);
	
	polyCount++;
//	PutFont(x,y,pat,0,0,r,g,b);
}

void QBGame::Line(int x1,int y1,int x2,int y2,int color)
{
	int i = polyCount;
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].line(x1,y1,x1+x2,y1+y2);
	polyCount = i;
}

void QBGame::Fill(int x1,int y1,int x2,int y2,int color)
{
	int i = polyCount;
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x1,y1,x1+x2,y1+y2);
	polyCount = i;
}

void QBGame::Box(int x1,int y1,int x2,int y2,int color)
{
	int i = polyCount;
#if 1
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x1,y1,x1+x2,y1+2);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x1+x2-2,y1,x1+x2,y1+y2);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x1,y1+y2-2,x1+x2,y1+y2);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].fill(x1,y1,x1+2,y1+y2);
#else
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].line(x1,y1,x1+x2,y1);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].line(x1+x2,y1+y2,x1+x2,y1);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].line(x1+x2,y1+y2,x1,y1+y2);
	poly[i].r = colortable[color][0];
	poly[i].g = colortable[color][1];
	poly[i].b = colortable[color][2];
	poly[i].alpha = 255;
	poly[i++].line(x1,y1+y2,x1,y1);
#endif
	polyCount = i;
}

/*
int QBGame::Rnd(int a)
{
	float d = (QBRand() % 32000)/32000.0;
//	float d = (QBRand() % 1024)/1024.0;
	return (int)(d*a);
//	return (rand() % (a+1));
}
*/

bool QBGame::LoadMap(const char* mapname)
{
	if (gameMap) delete gameMap;
	gameMap = new PPGameMap(PPGameResourcePath(mapname));
/*
	[gameMap release];
	gameMap = [[PPGameMap alloc] initWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[n stringByDeletingPathExtension] ofType:[n pathExtension]]];
*/
	if (gameMap) {
		map[0] = &gameMap->map[0];
		map[1] = &gameMap->map[1];
		map[2] = &gameMap->map[2];
		return true;
	}
	return false;
}

int QBGame::Locale()
{
	return PPGame_GetLocale();
/*
	//NSLog([[NSLocale currentLocale] objectForKey:NSLocaleLanguageCode]);
	NSString* code = NSLocalizedString(@"language",@"");
	if ([code isEqualToString:@"jp"]) {
		return QBGAME_LOCALE_JAPANESE;
	}
	return QBGAME_LOCALE_OTHER;
*/
}

int QBGame::InitBGM(int no,const char* key)
{
	return PPGame_InitBGM(no,key);
/*
	if (bgm[no-1] == nil) {
		bgm[no-1] = [[PPGameBGM alloc] init];
	}
	if (bgm[no-1] != nil) {
		[bgm[no-1] reset];
		bgm[no-1].key = [NSString stringWithUTF8String:key];
		[bgm[no-1] loadForKey:[NSString stringWithUTF8String:key]];
		bgm[no-1].selectedPlay = PPGame_GetSoundEnable();
	}
	return 0;
*/
}

void QBGame::releaseBGM()
{
	PPGame_ReleaseBGM();
/*
	for (int i=0;i<PPGAME_MAX_BGM;i++) {
		[bgm[i] release];
		bgm[i] = nil;
	}
*/
}

void QBGame::idleBGM(void* controller)
{
	PPGame_IdleBGM(controller,playBGM,playBGMOneTime,chooseBGM);
/*
	for (int no=1;no<=PPGAME_MAX_BGM;no++) {
		if (bgm[no-1]) {
			if (chooseBGM != 0) {
				if (chooseBGM == no) {
#if TARGET_OS_IPHONE
					[bgm[no-1] selectBGM:(UIViewController*)controller];
#endif
				} else
				if (chooseBGM < 0) {
					[bgm[no-1] reset];
					[bgm[no-1] saveForKey:bgm[no-1].key];
				}
			}
			if (playBGM != 0) {
				if (playBGM == no) {
					if (playBGMOneTime) {
						if (PPGame_GetSoundEnable()) [bgm[no-1] playOneTime];
						playBGMOneTime = false;
					} else {
						if (PPGame_GetSoundEnable()) [bgm[no-1] play];
					}
				} else
				if (playBGM < 0) {
					if (PPGame_GetSoundEnable()) [bgm[no-1] stop];
				}
			}
		}
	}
*/
	playBGM = 0;
	chooseBGM = 0;
}

void QBGame::SelectBGM(int no)
{
	chooseBGM = no;
}

void QBGame::PlayBGM(int no,bool repeat)
{
	if (!repeat) {
		playBGMOneTime = true;
	}
	playBGM = no;
}

void QBGame::StopBGM()
{
	playBGMOneTime = false;
	playBGM = -1;
}

void QBGame::ResetBGM()
{
	chooseBGM = -1;
}

void QBGame::RepeatKey(int firstDelay,int secondDelay)
{
	if (key == prekey && key != 0) {
		keyRepeatTimer ++;
		if (keyRepeatTimer > firstDelay) {
			keyRepeatTimer = secondDelay;
			prekey = 0;
		}
	}
	if (key == 0) {
		keyRepeatTimer = 0;
	}
}

unsigned long QBGame::GetKey()
{
	return key;
}

void QBGame::SetKey(unsigned long ikey)
{
	key = ikey;
}

PPGameTextureInfo* QBGame::TextureInfo()
{
	return NULL;
}

int QBGame::KeySize()
{
	return 64*64;
}

int QBGame::KeyCount()
{
	return 4;
}

unsigned long QBGame::WindowLayout()
{
	return QBGAME_CONTROLLER_TYPE_VERTICAL_CENTER;
}

unsigned long QBGame::VisibleButton()
{
	return QBGAME_CONTROLLER_ENABLE_ARROW | QBGAME_CONTROLLER_ENABLE_A | QBGAME_CONTROLLER_ENABLE_B;
}

void QBGame::Exit()
{
	exitGame = true;
}
